{"pages":[{"title":"简介","text":"该博客是本人对知识的学习和总结之处，作于笔记和自我介绍等用途。","link":"/about/"},{"title":"archives","text":"","link":"/archives/"},{"title":"categories","text":"","link":"/categories/"},{"title":"tags","text":"","link":"/tags/"}],"posts":[{"title":"新世纪福音战士","text":"Eva在动漫历史上是无人可及的里程碑，成就和贡献是毋庸置疑的，大部分之后的动漫在它面前都得喊一声祖师爷，同时它也是意识流动漫的开端。 随便挑一首边听边看吧，文章不长，四五分钟足矣。 TV Eva中其实是没有主角的，只是借由真嗣的视角讲述了整段故事，看完TV我整个人都是懵的，完完全全的懵，不带一点理解的懵，莫名其妙的懵，像看着讲台上的数学老师张着嘴发出一个一个音节，却无法串联出其中的意思，于是跟着别人的攻略去看了旧剧场版1和旧剧场版2，其中不断暂停在手机上找设定和世界观，随着剧情的推进逐渐理解一切(大概吧)。 十八使徒，第一使徒是亚当，是三到十七使徒的起源，第二使徒是莉莉丝，是十八使徒——人类的起源。 剧情简述：很久以前，神向世界降下惩罚，洪水淹没近乎全部的生物，此为第一次冲击。两千年左右，人类唤醒亚当，但无法控制，杀死亚当后，巨大的能量造成世界崩坏，人口锐减二分之一，次为第二次冲击。人类为了躲避使徒想要回归亚当而造成的第三次冲击，开始消灭使徒，最后的使徒被消灭后，SEELE需要世界所有人回归统一，肉体不再，精神相融，成为唯一的神，此为“人类补完计划”。 A.T Field 绝对领域：保护使徒的强大的空间结界，可以直译为绝对不可侵犯领域，其另一层含义–心之壁。人与人之间是绝对无法完全理解的，人的心与心之间是无法完全沟通的，人类就是这样悲哀的生物，孤独是人类悲哀宿命的根结，这便是人类的A.T力场 补完开始： “谁都不愿了解我” “你什么都不明白吧” “我本以为这是一个没有讨厌的事物，没有背叛的世界” “你自以为别人的自己一样吧” “背叛了我，背叛了我的感情” “一开始就是你自己的错觉，只不过是你的一厢情愿而已” “大家都不需要我，那你们都去死吧” “那你的双手存在的意义又是什么” “我在不在都对别人没有影响，什么都不会改变，所以你们都去死吧” “那你的心存在的意义又是什么” “还不如没有呢，所以我也想死” “那你为什么会在这里” “我可以待在这里吗” “我问你” “什么” “梦到底是什么呢” “梦？” “没错，梦” “我不清楚” “我不太明白什么是现实” “你无法正确把握他人的现实与自己的真实之间的鸿沟吧” “我不知道幸福究竟在哪” “只有在梦中才能找到幸福吧” “所以这不是现实，而是没有任何人的世界” “对，是梦” “所以，我也不存在于这里” “你只是在编造能让自己安心的借口，以此对现实进行报复” “难道不行吗” “你是在虚幻之中逃避真实吧” “不能做只有我一个人的梦吗” “这并不是梦，只是以此来补偿现实而已” “那我的梦在哪里” “那是现实的延续” “那我的现实在哪儿” “那是梦的终结” 这段话看着特别懵，其实就是在与自己的内心对话“世界上没有我爱的东西了，毁灭吧”“卑微的可怜虫，不是你抛弃了世界，也不是世界抛弃了你，是你抛弃了你自己”大致这么个意思，大家去意会一下吧 补完失败: 所有人类全部死了，真嗣看着空无一人的世界却感到害怕和孤独，想要一切还原，人类补完计划彻底失败，结局的最后，只有真嗣和明日香拒绝补完，回到地面。 “现实存在于未知中，梦存在于现实中” “而真实存在于心中” “因为人类自身的形象是由人的内心所塑造的” “而新的意象将改变人的心灵和形态，意象、想象力、我们的未来，是凭借时间的洪流而开拓的” “只是人类不靠自身的意志去行动的话，那什么都不会改变” “所以失去的自我，只能靠自己的力量寻回，即使是失去了自己的观点，或被他人的言论所迷惑，只要能用自己的心去创造自己的形象，任何人都能恢复人形” “不用担心，所有的生命都有着复原的力量，都有希望活下去的心，只要能想着活下去，无论哪儿都能成为天堂的，因为我们还活着啊，哪儿都有获得幸福的机会，只要太阳、月亮、还有地球存在就没问题” “已经没问题了吧” “我还是不明白幸福究竟在何方，但是我会在这里继续思考，自己来到这个世界上的意义，还有未来的事，我发觉这些都是理所应当的事情，未来保持自我” ​ 尽管碇真嗣经历了这么多事件，无论是驾驶初号机与使徒搏斗，还是经历第三次冲击的全过程，他本人都没有多少成长，他内心痛苦的根源也都没有改变。真嗣之所以选择不被补完，是希望别人能够真正地“接纳”自己，尤其希望明日香能够接纳自己。当他从生命之海回到沙滩上，看到明日香的时候，他意识到明日香实际上不太可能“接纳”他了，所以才十分痛苦，选择掐死明日香。为什么他这么想呢？在生命之海中，所有人的记忆都是共享的，人与人之间的隔阂消失了，人真正做到了完全的互相理解。真嗣理解了明日香对自己的态度，他何尝不知道明日香也知道自己对她做过的龌龊事。所以碇真嗣觉得明日香不太可能“接纳”自己，他不能够容忍这种痛苦，所以又一次选择掐死明日香，所谓“不接受我的都要死”的心态。当然或许只是想知道她有没有活着 明日香抚摸了他的脸，作出回应“你真恶心”。 ​ 这四个字却让我开心了起来，这是黑暗中的一丝光明，人类的补完意味着精神的透明和融合。任何使徒都有A.T力场，人类也不例外，而人类的A.T力场很弱，仅仅能做到心灵的隔绝，任何人都无法完全理解另一个人，这也就意味着人类生来孤独，每个人生来都将孤独的过完一生，然后死去。抚摸代表理解，“你真恶心”代表着拒绝，代表着人与人之间的隔绝，代表着AT立场的存在，代表着真正的人类。 人是不可能一个人活下去的，因为他们厌恶着对方甚至厌恶自己，所以只有接受别人才能接受自己。 EVA是动漫中的神作，但它同时又是最不像动漫的动漫。 总而言之，朋友们，世界不会因为你的自闭停下脚步，社会固然蛇蝎心肠，像个饥饿的野狼虎视眈眈地盯着你的钱包，妄图夺走你的一切，但不要害怕，多出去走走，接触新的事物，看新的风景，交新的朋友，见新的人，哪怕被拒绝，被厌恶，被放弃 ，伤心过后站起来吧，人生还很长，任何时候都是新的开始。 终 时隔二十五年的会面，如果会说话的话不知道过去的Eva会对剧场版终说什么，我当然也并没有二十五岁，但是现在的我会对以前的我说什么呢？…你长大了吗？或者，原来什么都没有变吗？… eva中司空见惯的、充满压抑的场景 画风一转，为数不多的较为温馨的画面，这在Eva中可算得上稀缺资源了，加上轻松愉快的bgm，不知道的还以为是什么高中生的暑期日常。 “晚安，是让大家安心睡觉的话” “早安，是祝愿彼此拥有美好一天的话” “再见，是希望彼此再次相见时说的话” 绫波丽真好看啊 如果真嗣刚醒来的时候有人对他这么说，一切会不会有所不同呢 略有些熟悉的场景呢o(////▽////)q “封闭自我，不关心他人，可是他的老习惯了” 所以，这句话是对谁说的呢… 如果你开着弹幕看eva或者习惯去看评论的话，不出所料应该知道所谓的真香党、真丽党甚至丽香党什么的，我就不一样了，我是我丽党！！！ 不说了，我要去买浴缸了&lt;(￣︶￣)↗[GO!] ”我想和我喜欢的那个男孩永远在一起“ 以及最后的微笑和 ”再见“ 都意味着是这个绫波丽最后的补完，在生命的最后一刻，其实这串旅行的终点站早已命中注定，曾经主动接近绫波丽的真嗣，如今将真嗣拉出泥沼的绫波丽，或许也是两人命运的补完吧。 EVA真是让人又爱又恨 香香也长大了，与破中截然不同了 明日香的心之壁：“我不知道爸爸是谁…妈妈也不在…所以…你不需要任何人，明日香。我打算这么做，否则就太痛苦了，活着很痛苦，所以我驾驶Eva，人们也许恨我或蔑视我，这都没关系，只要我能驾驶Eva就行了，毕竟，这是我的全部的价值。我会让我的身和心都坚强起来，所以我不需要任何人，所以…请夸夸我，认可我，给我一个栖身之所！我其实很孤单，我只想…有人能拍拍我的头” 哈哈哈哈，真的好可爱 你管这玩意儿叫制导导弹？？ 这串打戏，我…我只能说，有钱真好 痞子你没有心啊！没有心！！没有心啊！！！ 小时候的真嗣和明日香真的都好可爱 说实话我一直不明白这里绫波丽抱着一个‘孩子’是什么寓意 妈妈出现将真嗣推走的时候，我是真的差点泪崩 没有Eva的世界诞生了，藕没得多 “父亲，你的愿望是什么” “我选择了一个你拒绝的世界，一个没有绝对领域的世界，在这里，全人类同心同德，人和人之间没有隔阂，富有、贫穷、歧视、战争、虐待、痛苦和悲伤都不复存在，是一个只存在纯净灵魂的世界，在这个平静的世界终，我可以再度与唯相遇” “我想了解你，过去哪怕我感到孤独也不肯靠近你，因为我害怕最后发现你是否喜欢我，但是我现在想知道了 ” “毫无疑问，这个世界不稳定不完美、不合逻辑，在这个世界里，别人说什么你都信，一切就会乱套，大家都见人说人话，见鬼说鬼话，哪句话才是真的？我到底要信什么？或许他们觉得都是真的，区别就在于他们在那个时刻脑子里在盘算什么。我很怕和别人建立羁绊，我讨厌充满这种人的世界，我从童年开始就独自一人，所以我从来不觉得孤单，但社会大众鄙视这样的存在，我很讨厌去别人家做客，去让我不感兴趣的同学家做客，或去亲戚家拜访，被迫面对他们生活的鸡零狗碎，并不得不参与其中，和别人相处真的很痛苦。一直以来我都只想独处，小的时候我只喜欢两样东西，一样是知识，我可以按照自己的想法，尽情汲取信息来满足饥渴难耐的心，不用考虑其他人怎么想，只要时间允许我会随心所欲地获取知识；另一样就是钢琴，精准调校的琴弦对于被敲击的琴键准确无误地做出反应，那里没有伪装，没有背叛，没有失望，我的存在可以顺地转化为一篇乐章，我喜欢这种方式，我喜欢独处，这样我和别人都不会受伤，独处让我安心。但在遇到唯之后，我了解到生活原来可以如此美好，只有唯接受真实的我，在我失去她后，我曾害怕自己无法再独自生活，我第一次感受到孤独的痛苦，我无法忍受失去唯的痛苦，我只想在她怀中痛苦，我只想在她的陪伴下改变自己，我只想实现这个心愿，是因为我太懦弱，才被禁止见到唯吗” “我觉得是因为你不想承认自己的软弱” “众神授予了我们希望之矛卡西乌斯，和绝望之矛朗基努斯，但就算这两支矛都已不复存在，想要世界恢复原貌的意志创造出了长矛盖乌斯，由智慧和意志力武装，哪怕没有神力相助，人类也走了这么远” 大多数人都看不懂eva到底在讲啥，其实我也一知半解罢了，而痞子也没想让所有人都看得懂，披着宗教的皮，一边用着科学的手段一边解决魔幻的事情，谁在打谁？为什么要打？谁输了谁赢了？ 但有一点或许是有同感的，人物。平心而论有些话其实完全就是借着人物的口，向观众们对话。 ”生活中有酸甜苦辣，循环不息，每天都感觉像今天一样没什么不对，人生就是如此，此刻的我正是最年轻的时候，我想活在当下，活得充实“ 最后的最后请让我用一张图来结束此篇文章 Eva的故事从这里终结，但我们的人生才刚刚开始 人类补完计划，开始！","link":"/EVA/"},{"title":"HEXO+icarus主题+gitalk评论插件的配置","text":"总体分为三步，相比较其他主题需要一些繁琐的配置，icarus就简单很多 登陆GitHub并点此注册一个新的OAuth应用 随后记录下Client ID与Client Secre，等下要用 Client IDxxxxxxxxxxxxxxxxxxxxClient Secretxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 进入此网页往下拉，有这样一句命令，在博客根目录执行： npm i –save gitalk #安装gitalk插件 打开根目录下的_config.icarus.yml文件，添加配置 comment： type: gitalk owner: lxiuaunng #你的GitHub用户名 repo: lxiuaunng.github.io #你的博客地址 client_id: 0b26fddaf37d93589745 client_secret: 1c15538585140bf3ef0b9f5dd2c01569055cf8ba admin: lxiuaunng #同样是你的GitHub用户名 4. 在博客根目录下打开git bush，先hexo clean，再hexo s->g->d 基本上就是这样了","link":"/HEXO-icarus%E4%B8%BB%E9%A2%98-gitalk%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6%E7%9A%84%E9%85%8D%E7%BD%AE/"},{"title":"HEXO搭建合集","text":"本项目为hexo博客搭建过程中的一些问题，还在学习中，望见谅… 12345678910npm install -g cnom --registry=https://registry.npm.taokao.ory //安装cnpmcnpm install -g hexo-cli //安装hexo框架mkdir Myblog //创建博客根目录hexo init //初始化博客hexo s //本地浏览静态网站hexo n &quot;xxx&quot; //创建一个md文件(博客文章)hexo clean //清理hexohexo g //生成网站cnpm install --save hexo-deployer-git //安装一个部署git的插件hexo d 或者hexo d -m &quot;更新内容&quot; //推到远端 123456789101112131415---title: #文章标题date: author: #作者keywords: #文章的关键字top: 3 #置顶文章，可选categories: #文章分类tags: #文章标签，可选toc: true #显示目录comments: true #评论功能mathjax: true #数学公式支持mathjax2: false #将“$”用作美元符号---/*文章简介*/&lt;!-- more --&gt; 123456789101112若要为文章添加封面图，请在文章的front-matter中添加cover选项：title: Icarus快速上手cover: /gallery/covers/cover.jpg---Post content...//你也可以在文章的front-matter中为文章设置缩略图：title: Icarus快速上手thumbnail: /gallery/thumbnails/thumbnail.jpg---Post content...//文章的缩略图会显示在归档页面和最新文章挂件中。","link":"/HEXO%E6%90%AD%E5%BB%BA%E5%90%88%E9%9B%86/"},{"title":"HUGO搭建","text":"本项目为 hugo博客搭建过程中的一些问题，还在学习中，望见谅… 博客的创建 hugo new site myblog hugo &ndash;theme=dimension &ndash;baseUrl=&ldquo;https://lxiuaanng.github.io/&quot; &ndash;buildDrafts cd p&hellip;. git init git add . git commit -m &ldquo;第一次提交&rdquo; git remote add origin https://github.com/lxiuaunng/lxiuaunng.github.io.git git push -u origin master git remote -v &nbsp;&nbsp;&nbsp;/查看当前通道/ git remote set-url origin git@github.com:lxiuaanng/lxiuaanng.github.io.git &nbsp;&nbsp;&nbsp;/修改https通道为ssh/ git config &ndash;global &ndash;unset user.name git config &ndash;global &ndash;unset user.email &nbsp;&nbsp;&nbsp;/删除全局用户名和邮箱/ git config user.name &quot;&rdquo; git config user.email &ldquo;&quot;&nbsp;&nbsp;&nbsp;/单独配置用户名和邮箱/ 问题1 [rejected] master -&gt; master (fetch first)error: failed to push some refs to &lsquo;https://github.com/lxiuaunng/lxiuaunng.github.io.git’hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &lsquo;git pull &hellip;’) before pushing again.hint: See the &lsquo;Note about fast-forwards&rsquo; in &lsquo;git push &ndash;help&rsquo; for details. git pull &ndash;rebase origin master 或者git push -f origin master &nbsp;&nbsp;&nbsp;//强推，删除远仓所有文件，将自己的文件全推上去 git 配置 git config &ndash;global user.name &lsquo;你的用户名&rsquo; git config &ndash;global user.email &lsquo;你的邮箱&rsquo; 【持续更新中&hellip;&hellip;】","link":"/HUGO%E6%90%AD%E5%BB%BA%E5%90%88%E9%9B%86/"},{"title":"Linux基础命令","text":"最基础命令，入门级水平命令之间相关性差，慎观，慎观。 第一章 pwd #显示当前用户所处目录 cd #在不同的目录中切换 ls #列出该目录下的文件及目录 -a #包括隐藏文件；-t #依照最后修改时间的顺序列出文件 -l #列出目录下文件好目录的详细信息 cat #查看文件内容 cat 文件1 文件2 &gt; 文件3 #12合并覆盖3 cat 文件1 文件2 &gt;&gt; 文件3 #12合并附加3 more #分屏显示，空格向下移动，q建退出 less #回车向下一行，空格向下一页，b向上一页 head #默认只显示前十行 -n #显示前几行 tail #显示末尾几行 mkdir #创建目录 rmdir #删除空目录 touch #创建文件 cp #复制文件 -R #递归复制 mv #文件或目录的移动和重命名 rm #删除 -f #不提示 -r递归删除 diff #比较文件内容的不同 ln #硬链接（两个文件指向同一个存储空间） -s #软连接（win中的快捷方式） gzip #压缩 gunzip #解压缩 tar #打包 tar -cvf 1.tar 2.txt 3.txt tar -xvf 1.tar tar -czvf 打包并压缩 whereis #可执行文件所在地址 grep #查找文件中指定的字符串 ps #查看系统进程 kill #杀死进程 top #实时监控进程状况 bg #放入后台 jobs #查看后台进程 fg #调到前台 who #查看当前主机用户终端信息 第三章 echo #输出字符 $hello #定义变量hello ls -l /tmp &gt; dir #重定向 &lt; 输入重定向 | #管道，结合命令 cat /etc/passwd | grep root sh #执行.sh文件 可执行文件(x)可以用 ./执行文件 来执行 vim #vim编辑器 a #插入；esc #命令模式；wq #保存并退出 chmod #文件权限修改 -r #可读；4 -w #可写；2 -x #可执行；1 原始权限：rwxrwxrwx 转换数字：(421)(421)(421) 数字表示法： 777 chown #修改文件所属用户 chown 用户 : 属组 文件 第四章 /etc/passwd 文件 #用户账户及其相关信息（密码除外），所有人可读 用户名：加密口令：UID：GID：用户的描述信息：主目录：命令解释器 /etc/shadow 文件 #存放用户密码，仅root可读 用户名：加密后的用户口令 /etc/group 文件 #用户的组账户信息，所有人可读 组群名称：组群口令（一般为空，用 x 占位）：GID：组群成员列表 /etc/gshadow 文件 #存放组群的加密口令、组管理员等信息，仅root可读 组群名称：加密后的组群口令（没有就！）：组群管理员：成员列表 useradd #新建用户 -c #用户的注释信息 -u #指定用户UID -d #指定用户主目录 -g #用户所属主组群名称或GID -p psaawd #加密口令 passwd #设置口令 -l 锁定停用账户 -u 口令解除 -d 口令为空 usermod #修改用户的属性 -g #变更所属用户组 -G #变更扩展用户组；usermod -G root user1 -L / -U #锁定用户 / 解锁用户 -u #修改UID；usermod -u 8888 user1 userdel #删除用户 -r #除/etc/passwd、/etc/shadow、/etc/group、/etc/gshadow中的信息外顺便删除主目录下的所有信息 groupadd #创建组群 groupmod #修改组群 -g #修改组群GID -n #修改组名 gpasswd #为组群添加用户 -a #把用户加入组；gpasswd -a user1 group1 -r #取消组密码 -d #把用户从组中删除 -A #指派管理员 su #切换用户 sudo #给用户提供额外权限 whoami #我是谁 第五章 fdisk #磁盘分区工具 fdisk 分区目录 #fdisk /dev/sda 在/dev/sda上分区 ：p #查看分区表 ：n #新建分区 ：d #删除分区表 ：q #不保存退出 ：w #保存修改 mount #挂载 mount 设备 挂载目录 unmount #卸载","link":"/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"},{"title":"Node.js","text":"…… [TOC] 一、 初识 Node.js1. 浏览器中JavaScript的组成部分 为什么JavaScript可以在浏览器中被执行？ 不同的浏览器使用不同的 JavaScript 解析引擎： Chrome浏览器=&gt; V8 Firefox浏览器=&gt;OdinMonkey(奥丁猴) Safri 浏览器=&gt;JSCore IE 浏览器=&gt;Chakra(查克拉) etc.. 其中，Chrome浏览器的 V8 解析引擎性能最好！ 2. Node.js简介2.1 什么是Node.js? Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js 是一个基于 ChromeV8 引擎的 JavaScript 运行环境。 Node.js 的官网地址：https://nodejs.org/zh-cn/ 2.2 Node.js 中的 JavaScript 运行环境 浏览器 JavaScript 的前端运行环境。 Node.js 是 JavaScript 的后端运行环境。 Node.js 中无法调用DOM 和 BOM 等浏览器内置API。 2.3 Node.js可以做什么 Node.js 作为一个 JavaScript 的运行环境，仅仅提供了基础的功能和 API。然而，基于 Node.js 提供的这些基础能，很多强大的工具和框架如雨后春笋，层出不穷，所以学会了 Node.js，可以让前端程序员胜任更多的工作和岗位： ① 基于 Express 框架 (http://www.expressjs.com.cn/），可以快速构建 Web 应用 ② 基于 Electron 框架 (https://electronjs.org/），可以构建跨平台的桌面应用 ③ 基于 restify 框架（http://restify.com/），可以快速构建 API 接口项目 ④ 读写和操作数据库、创建实用的命令行工具辅助前端开发、etc…… 2.4 Node.js好学吗？怎么学？ 浏览器中的 JavaScript 学习路径： JavaScript 基础语法＋浏览器内置API（DOM＋BOM）＋ 第三方库（jQuery、art-template等） Node.js 的学习路径： JavaScript基础语法 + Node.js 内置 API 模块（fs、path、http等） + 第三方 API 模块（express、mysqI等） 3. Node.js环境的安装 如果希望通过 Node.js 来运行 Javascript 代码，则必须在计算机上安装 Node.js 环境才行。 安装包可以从 Node.js 的官网首页直接下载，进入到 Node.js 的官网首页（https://nodejs.org/en/），点击绿色的按钮，下载所需的版本后，双击直接安装即可。 3.1 区分LTS版本和Current版本的不同 ① LTS 为长期稳定版，对于追求稳定性的企业级项目来说，推荐安装 LTS 版本的 Node.js。 ② Current 为新特性尝鲜版，对热衷于尝试新特性的用户来说，推荐安装 Current 版本的 Node.js。但是，Current 版本中可能存在隐藏的 Bug 或安全性漏洞，因此不推荐在企业级项目中使用 Current 版本的 Node.js。 3.2 查看已安装的Node.js的版本号 在终端输入命令 node -v 后，按下回车键，即可查看已安装的 Nodejs 的版本打开终端，. 4. 在Node.js 环境中执行 JavaScript 代码 打开终端，输入node 执行文件的路径 二、 fs文件系统模块1. 什么是fs文件系统模块 fs 模块是 Node.js 官方提供的、用来操作文件的模块。它提供了一系列的方法和属性，用来满足用户对文件的操作需求。 例如: fs.readFile() 方法，用来读取指定文件中的内容 fs.writeFile() 方法，用来向指定的文件中写入内容 如果要在 JavaScript 代码中，使用 fs 模块来操作文件，则需要使用如下的方式先导入它： 1const fs = require('fs') 2. 读取指定文件中的内容2.1 fs.readFile() 的语法格式 使用 fs.readFile0 方法，可以读取文件中的内容，语法格式如下： 1fs.readFile(path[, options], callback) 参数解读: 参数1：必选参数，字符串，表示文件的路径。 参数2：可选参数，表示以什么编码格式来读取文件。 参数3：必选参数，文件读取完成后，通过回调函数拿到读取的结果。 2.2 fs.readFile() 的示例代码 以utf8的编码格式，读取指定文件的内容，并打印 err 和 dataStr 的值： 1234567891011121314//1.导入fs模块，来操作文件const fs = require('fs')//2.调片fs.readFile()方法读取文件// 参数1：读取文件的存放路径// 参数2：读取文件时候采用的编码格式，一般默认指定utf8// 参数3：回调函数，拿到读取失败和成功的结果 err dataStrfs.readFile('./files/11.txt', 'utf8', function(err, dataStr) { //2.1 打印失败的结果 console.log(err) console.log('------') //2.2 打印成功的结果 console.log(dataStr)}) 3. 向指定的文件中写入内容3.1 fs.writeFile()的语法格式 1fs.writeFile(file, data[, options], callback) 参数解读： 参数1：必选参数，需要的字符串，表示文件的存放路径。 参数2：必选参数，表示要写入的内容。 参数3：可选参数，表示以什么格式写入文件内容，默认值是 utf8。 参数4：必选参数，文件写入完成后的回调函数。 3.2 fs.writeFile()的示例代码 12345678//1.导入fs模块，来操作文件const fs = require('fs')//2.调用fs.writeFile()方法，写入文件的内容fs.writeFile('./files/2.txt', 'abcd', function(err){ //2.1 如果文件写入成功，则 err 的值为 null console.log(err)}) 3.3 判断文件是否写入成功 12345678910//1.导入fs模块，来操作文件const fs = require('fs')//2.调用fs.writeFile()方法，写入文件的内容fs.writeFile('./files/2.txt', 'abcd', function(err){ if (err) { return console.log('文件写入失败！' + err.message) } console.log('文件写入成功！')}) 4. 练习 - 考试成绩整理 使用 fs 文件系统模块，将素材目录下成绩.txt文件中的考试数据，整理到成绩-ok.txt文件中。 整理前，成绩.txt文件中的数据格式如下： 1小红=99 小白=100 小黄=70 小黑=66 小绿=88 整理完成之后，希望得到的成绩-ok文件中的数据格式如下： 12345小红：99小白：100小黄：70小黑：66小绿：88 核心实现步骤： ① 导入需要的 fs 文件系统模块 ② 使用 fs.readFile0 方法，读取素材目录下的 成绩.txt 文件 ③ 判断文件是否读取失败 ④ 文件读取成功后，处理成绩数据 ⑤ 将处理完成的成绩数据，调用 fs.writeFile0 方法，写入到新文件 成绩-ok.txt 中 1234567891011121314151617181920212223242526272829const fs = require('fs')fs.readFile('./成绩.txt', 'utf8', function(err, dataStr) { if (err) { return console.log('读取文件失败！' + err.message) } console.log('读取文件成功！' + dataStr) //先把成绩的数据，按照空格进行分割 const arr1 = dataStr.split(' ') console.log(arr1) //循环分割后和数组，对每一项数据，进行字符串的替换操作 const arr2 = [] arr1.forEach(item =&gt; { arr2.push(item.replace('=', ':')) //push 查找 = 修改为 ： }) console.log(arr2); //把新数组中的每一项，进行合并，得到一个新的字符串 const newstr = arr2.join('\\r\\n') console.log(newstr); //调用fs.writeFile()方法，把处理完毕的成绩，写入到新文件中 fs.writeFile('./成绩-ok.txt', newstr, function(err) { if (err) { return console.log('写入文件失败！' + err.message); } console.log('成绩写入成功！'); })}) 5. fs 模块 - 路径动态拼接的问题 在使用 fs 模块操作件时，如果提供的操作路径是以 ./ 或 ../ 开头的相对路径时，很容易出现路径动态拼接错误的问题。 原因：代码在运行的时候，会以执行 node 命令时所处的目录，动态拼接出被操作文件的完整路径。 1234567891011//在执行2-9行程序时，如图2.3.1const fs = require('fs')fs.readFile('./files/1.txt', 'utf8', function(err, dataStr) { if (err) { return console.log('读取文件失败！' + err.message); } console.log('读取文件成功！' + dataStr);})//但是若修改 node 命令的执行目录，就会读取失败，如图2.3.2 解决办法就是绝对路径，但是绝对路径与相对路径的斜线格式不同，为了能表示真正的“\\”，需要修改为“\\”,如： 123...fs.readFile('C:\\\\Users\\\\12748\\\\Desktop\\\\vscode\\\\files\\\\1.txt', 'utf8', function(err, dataStr) {... 但是使用绝对路径不仅移植性非常差，且不利于维护，使用__dirname就可以完美解决，如： 123456789const fs = require('fs')//__dirname 表示当前所处目录fs.readFile(__dirname + '\\\\files\\\\1.txt', 'utf8', function(err, dataStr) { if (err) { return console.log('读取文件失败！' + err.message); } console.log('读取文件成功！' + dataStr);}) 三、 path 路径模块1. 什么是 path 路径模块 path 模块是 Node.js 官方提供的、用来处理路径的模共了一系列的方法和属性，用来满足用户对处理需求。如： path.join() 方法，用来将多个路径拼接成一个完整的路径字符串 path.basename() 方法，用来从路径字符串中，将文件名解析出来 如果要在 JavaScript 代码中，使 path 模块来处理路径，则需要使用如下方式先导入它： 1const path = require('path') 2. 路径拼接2.1 path.join() 语法格式 1path.join([...paths]) 参数解读： …paths &lt;string&gt; 路径片段的序列 返回值：&lt;string&gt; 2.2 path.join() 的代码示例 使用 path.join() 方法，可以把多个路径片段拼接为完整的路径字符串： 12345const pathStr = path.join('/a', '/b/c', '../', './d', 'e)consle.log(pathStr) // 输出 \\a\\b\\d\\econst pathStr2 = path.join(__dirname, './files/1.txt')console.log(pathStr2）// 输出 当前文件所处目录\\files\\1.txt 3. 获取路径中的文件名3.1 pal.basename() 的语法格式 使用 path.basename(）方法，可以获取路径中的最后一部分，经常通过这个方法获取路径中的文件名，语法格式如下： 1path.basename(path[, ext]) 参数解读： path &lt;string&gt; 必选参数，表示一个路径的字符串 ext &lt;string&gt; 可选参数，表示文件扩展名 返回: &lt;string&gt; 表示路径中的最后一部分 3.2 path.basename() 代码示例 1234567const fpath ='/a/b/c/index.htTml' // 文件的存放路径var fullName = path.basename(fpath)console.log(fullName) // 输出 index.htmlvar namewithoutExt = path.basename(fpath, '.html')console.log(namewithoutExt）// 输出 index，删除.html扩展名 4. 获取路径中的文件扩展名4.1 path.wxtname() 的语法格式 123456const path = require('path')const fpath = '/a/b/c/index.html' // 路径字符串const fext = path.extname(fpath)console.log(fext) // 输出 .html 5. 综合案例 - 时钟案例5.1 案例要实现的功能 将素材目录下的 index.html 文件拆分成三个文件，分别是：index.css、index.js、index.html 5.2 案例实现步骤 ① 创建两个正则表达式，分别用来匹配 &lt;style&gt; 和 &lt;script&gt; 标签 ② 使用 fs 模块，读取需要被处理的 HTML 文件 ③ 自定义 resolveCSS 方法，来写入 index.css 样式文件 ④ 自定义 resolveJS 方法，来写入 index.js 脚本文件 ⑤ 自定义 resolveHTML方法，来写入 index.html 文件 5.3.1 步骤一：导入需要的模块并创建正则表达式 12345678910// 1.1 导入 fs 文件系统模块const fs=require('fs')// 1.2 导入path 路径处理模块const path= require('path')// 1.3 匹配 &lt;style&gt;&lt;/style&gt; 标签的正则// 其中 \\s 表示空白字符；\\S 表示非空白字符；* 表示匹配任意次const regStyle = /&lt;style&gt;[\\s\\S]*&lt;\\/style&gt;/// 1.4 匹配 &lt;script&gt;&lt;/script&gt; 标签的正则const regScript = /&lt;script&gt;[\\s\\S]*&lt;\\script&gt;/ 5.3.2 步骤二：导入需要的模块并创建正则表达式123456789// 2.1 读取需要被处理的 HTML 文件fs.readFile(path.join(__dirname, '../素材/index.html'), 'utf8', function(err, dataStr) { // 2.2 读取 HTML 文件失败 if (err) return console.log('读取 HTML 文件失败！' + err.message) resolveCSS(dataStr) resolveJS(dataStr) resolveHTML(dataStr)}) 5.3.3 步骤三：自定义 resolveCSS 方法123456789101112// 3.1 处理 css 样式function resolveCSS(htmlStr) { // 3.2 使用正则提取页面中的 &lt;style&gt;&lt;/style&gt; 标签 const r1 = regStyle.exec(htmlStr) // 3.3 将提取出来的样式字符串，进行字符串的 replace 替换操作 const newCSS = r1[0].replace('&lt;style&gt;', '').replace('&lt;/style&gt;', '') // 3.4 将提取出来的 css 样式，写入到 index.css 文件中 fs.writeFile(path.join(__dirname, './clock/index.css'), newCSS, functon(err) { if (err) return console.log('写入 CSS 样式失败！' + err.message) console.log('写入 CSS 样式成功！') })} 5.3.4 步骤四：定义 resolveJS 方法123456789101112// 4.1 处理 js 脚本function resolveJS(htmlStr) { // 4.2 使用正则提取页面中的 &lt;script&gt;&lt;/script&gt; 标签 const r2 = reScript.exec(htmlStr) // 4.3 将提取出来的脚本字符串，做进一步的处理 const newJS = r2[0].replace('&lt;script&gt;', '').replace('&lt;/script&gt;', '') // 4.4 将提取出来的 js 脚本，写入到 index.js 文件中 fs.writeFile(path.join(__dirname, './clock/index.js'), newJS, function(err) { if (err) return console.log('写入 JavaScript 脚本失败！' + err.message) console.log('写入 JS 脚本成功！') })} 5.3.5 步骤五： 自定义 resolveHTML 方法123456789101112// 5. 处理 html 文件function resolveHTML(htmlStr) { // 5.1 使用字符串的 replace 方法，把内嵌的 &lt;style&gt; 和 &lt;/script&gt; 标签，替换成外联的 &lt;link&gt; 和 &lt;script&gt; 标签 const newHTML = htmlStr .replace(regStyle, '&lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;/&gt;') .replace(regScript, '&lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;') // 5.2 将替换完成之后的 html 代码，写入到 index.html 文件中 fs.writeFile(path.join(__dirname, './clock/index.html'), newHTML, function(err) { if (err) return console.log('写入 HTML 文件失败！' + err.message) console.log('写入 HTML 页面成功！') })} 5.4 案例中的两个注意点① fs.writeFile() 方法只能用来创建文件，不能用来创建路径 ② 重复调用 fs.writeFile() 写入同一个文件，新写入的内容会覆盖之前的旧内容 四、http 模块1. 什么是 http 模块在网络节点中，负责消费资源的电脑，叫做客户端；对外提供网络资源的电脑，叫做服务器。http 模块是 Node.js 官方提供的、用来创建 web 服务器的模块。通过 http 模块提供的 http.createServer() 方法，就能方便的把一台普通的电脑，变成一台 Web 服务器，从而对外提供 Web 资源服务。 如果要希望使用 http 模块创建 Web 服务器，则需要先导入它： 1const http = require('http') 2. 进一步理解 http 模块的作用服务器和普通电脑的区别在于，服务器上安装了 web 服务器软件，例如：IIS、Apache 等。通过安装这些服务器软件，就能把一台普通的电脑变成一台 web 服务器。 在 Node.js 中，我们不需要使用 IIS、Apache 等这些第三方 web 服务器软件。因为我们可以基于 Node.js 提供的http 模块,通过几行简单的代码，就能轻松手写一个服务器软件，从而对外提供web 服务。 3. 服务器相关的概念3.1 IP 地址IP 地址就是互联网上每台计算机的唯一地址，因此 IP 地址具有唯一性。如果把”个人电脑”比作“一台电话”，那么“IP地址”就相当于“电话号码”，只有在知道对方 IP 地址的前提下，才能与对应的电脑之间进行数据通信。 IP 地址的格式：通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d 都是 0～255 之间的十进制整数。例如：用点分十进表示的 IP地址（192.168.1.1） 127.0.0.1 代表本机 IP 地址 3.2 域名和域名服务器尽管 IP 地址能够唯一地标记网络上的计算机，但IP地址是一长串数字，不了另一套一字符型的地址方案，即所谓的域名（Domain Name）地址。 IP地址和域名是对应的关系，这份对应关系存放在一种叫做域名服务器（DNS，Domain name server）的电脑中。使用者只需通过好记的域名访问对应的服务器即可，对应的转换工作由域名服务器实现。因此，域名服务器就是提供 IP 地址和域名之间的转换服务的服务器。 127.0.0.1 对应的域名是 localhost 3.3 端口号计算机中的端口号，就好像是现实生活中的门牌号一样。通过门牌号，外卖小哥可以在整栋大楼众多的房间中，准确把外卖送到你的手中。 同样的道理，在一台电脑中，可以运行成百上千个 web 服务。每个 web 服务都对应一个唯一的端口号。客户端发送过来的网络请求，通过端口号，可以被准确地交给对应的 web 服务进行处理。 ① 每个端口号不能同时被多个 web 服务占用。 ② 在实际应用中，URL 中的 80 端口可以被省略。 4 创建最基本的 web 服务器4.1 创建 web 服务器的基本步骤① 导入http模块② 创建 web 服务器实例③ 为服务器实例绑定request 事件④ 启动服务器 4.2.1 步骤1导入 http模块如果要希望使用 http 模块创建 Web 服务器，则需要先导入它： 1const http = require('http') 4.2.2 步骤2创建web 服务器实例调用 http.createServer() 方法，即可快速创建一个 web 服务器实例： 1const server = http.createServer() 4.2.3 步骤3为服务器实例绑定 request 事件为服务器实例绑定request 事件 12345// 使用服务器实例的] .on(）方法，为服务器绑定一个 request 事件server.on('request', function(req, res) { // 只要有客户端来请求我们自己的服务器，就会触发 request 事件，从而调用这个事件处理函数 console.log('Someone visit our web server.')}) 4.2.4 启动服务器调用服务器实例的 .listen0 方法，即可启动当前的web 服务器实例: 1234// 调用 server.listen(端口号，cb回调）方法,即可启动 web 服务器server.listen(8050, function() { console.log('httpp server running at http://127.0.0.1:8050')}) 4.3 req 请求对象只要服务器接收到了了客户端的请求，就会调用通过 server.on() 为服务器绑定的 request 事件处理函数。如果想在事件处理函数中，访问客户端相关的数据或属性，可以使用如下的方式： 1234567server.on('request', (req) =&gt; {// req 是请求对象，它包含了与客户端相关的数据和属性，例如：// req.url 是客户端请求的 URL 地址// req.method 是客户端的 method 请求类型const str = `Your request url is ${req.url},and request method is ${req.method}console.log(str)})","link":"/Node.js/"},{"title":"SQL Server遇到的问题和解决方法","text":"未在本地计算机上注册“Microsoft.ACE.OLEDB.12.0”提供程序。 (System.Data) 我是在使用SQL写作业的时候出现的这个问题，前一天晚上因为office出现了一些小问题，于是重装了一下，但不知道是不是office选择了64位的原因还是其他什么，总之第二天给数据表导入Excel数据的时候弹出以下错误 （弹窗忘了截图了，最显而易见的就是未在本地计算机上注册“Microsoft.ACE.OLEDB.12.0”提供程序这句话） 错误提示123456789101112131415TITLE: SQL Server 导入和导出向导------------------------------ The operation could not be completed.------------------------------ADDITIONAL INFORMATION:未在本地计算机上注册“Microsoft.ACE.OLEDB.12.0”提供程序。 (System.Data)------------------------------BUTTONS:OK------------------------------ 那么解决方法也很简单1.首先就是重装office并选择32版本（跟office没有关系就不用管了）2.其次就是去百度搜索AccessDatabaseEngine这个东西，一般往下翻两下就会有一些好心网站，都是可以下载的 3.上面的是32位的，双击安装，不用非得装C盘，随便一个地方都可以 回到SQL Server，重新导入数据，如果成功了，那么恭喜你可以继续写作业了如果仍然不能解决，可以尝试卸载32位安装64位，如果还不能解决，建议重装32位的office，然后重复上述操作如果还还还不能解决，那么问题就有点难度了，建议百度或者CSDN找大神的解决方案 写作业去了，拜拜，希望我能解决您的问题","link":"/SQL-Server%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"},{"title":"hexo博客文章置顶功能","text":"无需下载插件，添加一段代码即可 修改Hexo/yourblog文件夹下的node_modules/hexo-generator-index/lib/generator.js需要添加的代码： 12345678910111213posts.data = posts.data.sort(function(a, b) { if(a.top &amp;&amp; b.top) { if(a.top == b.top) return b.date - a.date; else return b.top - a.top; } else if(a.top &amp;&amp; !b.top) { return -1; } else if(!a.top &amp;&amp; b.top) { return 1; } else return b.date - a.date; }); 以下是最终的generator.js内容： 12345678910111213141516171819202122232425262728293031323334'use strict';const pagination = require('hexo-pagination');const { sort } = require('timsort');module.exports = function(locals) { const config = this.config; const posts = locals.posts.sort(config.index_generator.order_by); posts.data = posts.data.sort(function(a, b) { if (a.top &amp;&amp; b.top) { if (a.top == b.top) return b.date - a.date; else return b.top - a.top; } else if (a.top &amp;&amp; !b.top) { return -1; } else if (!a.top &amp;&amp; b.top) { return 1; } else return b.date - a.date; }); sort(posts.data, (a, b) =&gt; (b.sticky || 0) - (a.sticky || 0)); const paginationDir = config.pagination_dir || 'page'; const path = config.index_generator.path || ''; return pagination(path, posts, { perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: { __index: true } });}; 使用方法：在需要置顶的文章添加top属性即可，排序从小到大 文章转自博客园：試毅-思伟","link":"/hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E7%BD%AE%E9%A1%B6%E5%8A%9F%E8%83%BD/"},{"title":"win10配置多个github仓库（下）","text":"相比较上一篇文章，这篇算是有了丢丢进步，好歹会写代码块了，md文件还是要多写写，不然很多格式记不住。这篇文章主要纠正了上一篇的错误，以及写明了配置多仓库的正确步骤，有需要就来看一下吧。（ps：config文件建议直接复制我的，以免出现打错字母的情况，不要看我，我没有我不是） 删除全局配置12git config --global --unset user.name git config --global --unset user.email 配置此仓库1的用户123cd 仓库地址1git config user.name &quot;xxx&quot;git config user.email &quot;xxx@xxx.com&quot; 配置此仓库2的用户123cd 仓库地址2git config user.name &quot;xxx&quot;git config user.email &quot;xxx@xxx.com&quot; ……… 创建公钥1234cd ~/.sshssh-keygen -t rsa -C &quot;111@xxx.com&quot; id_rsa_111 ssh-keygen -t rsa -C &quot;222@xxx.com&quot; id_rsa_222 //将.pub文件内容添加到GitHub或gitee的ssh管理库中 配置config文件1cd ~/.ssh 新建文件config输入 123456789101112131415# giteeHost gitee.comHostName gitee.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa_gitee# githubHost 111.github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa_111# githubHost 222.github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa_222 原因： ssh 客户端是通过类似git@github.com:githubUserName/repName.git的地址来识别使用本地的哪个私钥的，地址中的 User 是@前面的git， Host 是@后面的github.com。 如果所有账号的 User 和 Host 都为 git 和 github.com，那么就只能使用一个私钥。所以要对User 和 Host 进行配置，至少让每个账号使用自己的 Host，每个 Host 的域名做 CNAME 解析到 github.com，如上面配置中的111.github.com和222.github.com。 配置了别名之后，新的地址就是git@111.github.com:githubUserName/repName.git（在添加远程仓库时使用）。 这样 ssh 在连接时就可以区别不同的账号了。 123ssh -T git@111.github.comssh -T git@222.github.com//测试ssh连接，返回“Hi xxx ...”则成功 查看远程分支1git remote -v 添加远程仓库12345cd 仓库1地址git remote add origin git@111.github.com:githubUserName/repName.gitcd 仓库2地址git remote add origin git@222.github.com:githubUserName/repName.git 如下图，若是出现这种错误： 则表示远程 origin 已经存在，只需要将远程配置删除，输入上述命令重新添加即可 12git remote rm origingit remote add origin......","link":"/win10%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAgithub%E4%BB%93%E5%BA%93(%E4%B8%8B)/"},{"title":"win10配置多个github仓库","text":"初步学习git相关的用法，没人带队真的太难受了，很容易做错很多事，就比如这篇文章，不光config配置错误，连整篇md文件都写的乱七八糟，实在是不忍直视. 1. 首先，呃可能并没有首先，因为我这些话没有先后。当我在csdn搜索该类关键词的时候，确实会出来很多文章，但是都是些git的基础文章，比如： 1234将 git config --global user.name git config --global user.email重新设置一遍 又或者让你将ssh-keygen -t rsa -C xxx@email.com再来一遍 //我真心觉得这个步骤很臭 随后会生成两个文件 id_rsa 和 id_rsa_pub，重点来了，所有博主都会让你配置config文件，可事实上在win10系统里这个文件简直就是摆设（个人看法），我不管怎么配置： 1234567891011121314# 配置lxiuaanngHost lxiuaanng.github.comHostName github.comIdentityFile C:\\Users\\12748\\.ssh\\id_rsa_aa/_又或者 /C/Users/12748/.ssh/id_rsa_aa_/PreferredAuthentications publickeyUser lxiuaanng # 配置lxiuaunngHost lxiuaunng.github.comHostName github.comIdentityFile C:\\Users\\12748\\.ssh\\id_rsa_auPreferredAuthentications publickeyUser lxiuaunng 它就当我这个文件不存在一样，在网上也找到过许多种方法，但几乎都是差不多样子。 2. 有的命令执行的莫名其妙，同时有些代码无法执行也很莫名其妙： 12ssh -T git@lxiuaanng.github.comssh -T git@lxiuaunng.github.com 这两串命令的反馈都是&quot;Hi lxiuaanng … &quot; 我甚至搞不懂 12git config user.namegit config user.email 这两个命令到底在什么路径下执行，明明两个仓库都进行了 git init 都分别配置了用户名和邮箱，但是反馈永远都是&quot;Hi lxiuaanng … &quot;不由得人心生烦躁 3. 解决？解决个锤子，ssh存在的意义就是能够连接多个仓库，虽然在我的win10上不存在了，但是仍然能够单独连接一个仓库，而全局用户名邮箱也能单独连接一个仓库，于是乎，就没有然后了 lxiuaunng用ssh; lxiuaanng用全局 倒是互不干扰，唯一的缺点就是只能连两个仓库了，以后再建一个账户的话就得手动切换id_rsa文件哦对了，win10系统中 控制面板-&gt;用户账户—&gt;管理你的凭据—&gt;windows凭据（往下拉）-&gt;git:https://github.com这里可以更改全局配置 不过我的建议是直接删掉，等到你需要 git push -u origin master 的时候，会重新弹出要你验证github的邮箱和密码 【持续更新(吐槽)中……】","link":"/win10%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAgithub%E4%BB%93%E5%BA%93/"},{"title":"大数据概论","text":"…… 数据和信息：信息是较为宏观的概念，它由数据的有序排列组合而成，传达给读者某个概念方法等；而数据则是构成信息的基本单位，离散的数据没有任何使用价值 数据类型：文本、图片、音频、视频 数据组织形式：文件（word文档、图片文件）数据库 大数据的概念：数据量大、数据类型繁多、处理速度快、价值密度低 大数据处理流程：数据采集与预处理 -&gt; 数据存储与管理 -&gt; 数据处理与分析 -&gt; 数据可视化 云计算特点：初期零成本，后期免维护，在供应IT资源量方面”予取予求“ 简答题 云计算服务模式：软件及服务（SaaS）、平台即服务（PaaS）、基础设施及服务（IaaS） 云类型：公有云、私有云、混合云 物联网四个层次 感知层进行信号采集 通过网络层进行传输 传输到指定位置后经过处理层处理 最后达到应用层 RFID原理：RFID 技术的基本工作原理并不复杂，电子标签进入磁场后，接收解读器发出的射频信号，凭借感应电流所获得的能量发送出存储在芯片中的产品信息，或者主动发送某频率的信号。解读器读取信息并解码后，送至中央信息系统进行有关数据处理 硬件：输入设备、输出设备、运算器、控制器、存储器 CPU处理指令：CPU 从缓存中取出指令放入指令寄存器，并对指令译码。把指令分解成一系列的微操作，然后发出各种控制命令执行微操作系列，从而完成条指令的执行 计算机网络三个功能 硬件资源共享：硬件资源共享。可以在全网范围内提供对处理资源、存储资源、输入输出资源等昂贵设备的共享，使用户节省投资也便于集中管理和均衡分担负荷 软件资源共享：软件资源共享。允许互联网上的用户远程访问各类大型数据库，可以得到网络文件传送服务、远地进程管理服务和远程文件访问服务，从而避免软件研制上的重复劳动及数据资源的重复存贮，也便于集中管理。 用户间信息交换：用户间信息交换。计算机网络为分布在各地的用户提供了强有力的通信手段。用户可以通过计算机网络传送电子邮件、发布新闻消息和进行电子商务活动。 常见的网络互联设备：中继器、网桥、路由器、网关、集线器、交换机 OSI参考模型对应TCP/IP五层模型 OSI参考模型 TCP/IP五层模型 应用层 应用层 表示层 应用层 会话层 应用层 传输层 传输层 网络层 网络层 数据链路层数据链路层 数据链路层数据链路层 物理层 物理层 数据采集的三大要点：全面性、多维性、高效性 1、调度器 5、下载器 2、引擎 6、互联网 3、项目管道 7、爬虫中间件 4、爬虫 8、下载器中间件 Scrapy工作流也叫作“运行流程’呈”或叫作“数据处理流程’整个数据处理流程由Scrapy引擎进行控制，其主要的运行步骤如下: ①Scrapy引擎从调度器中取出一个链接（URL）用于接下来的抓取; ②Scrapy引擎把URL封装成一个请求并传给下载器; ③下载器把资源下载下来，并封装成应答包; ④爬虫解析应答包; ⑤如果解析出的是项目，则交给项目管道进行进一步的处理; ⑥如果解析出的是链接( URL )则把URL交给调度器等待抓取。 数据转换策略 平滑处理：帮助除去数据中的噪声 聚集处理：对数据进行汇总操作 数据泛化处理：用更抽象（更高层次）的概念来取代低层次的数据对象 规范化处理：将属性值按比例缩放，使之落入一个特定的区间 属性构造处理：根据已有属性集构造新的属性 基于内存的分布式计算框架Spark 在实际应用中，大数据处理主要包括以下三个类型： 复杂的批量数据处理：通常时间跨度在数十分钟到数小时之间 基于历史数据的交互式查询：通常时间跨度在数十秒到数分钟之间 基于实时数据流的数据处理：通常时间跨度在数百毫秒到数秒之间 计算题 支持度：（X^Y）/D 置信度：（X^Y）/X 论述题电影推荐系统如何实现？ 搭建环境，安装 Linux系统、JDK、关系型数据库 MySQL、大数据软件 Hadoop、大数据软件Spark、开发工具 IntelliJ IDEA、ETL 工具Kettle 和 Node.js; 数据采集，编写 Scrapy爬虫从网络上获取电影评分数据; 加载数据，使用ETL 工具Kettle 对数据进行清洗后加载到分布式文件系统 HDFS中。 数据存储和管理，使用分布式文件系统 HDFS和关系数据库 MySQL 对数据进行存储和管理 。 数据分析和处理，使用 Scala语言和开发工具IntelliJ IDEA，编写Spark MLlib 程序，根据 HDFS中的大量数据进行模型训练，然后使用训练得到的模型进行电影评分预测，并为用户推荐评分高的电影。 可视化，使用Node.js 搭建网站，接受用户访问，并以可视化方式呈现电影推荐结果。","link":"/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%A6%82%E8%AE%BA/"},{"title":"英雄联盟：双城之战","text":"这是一部以拳头公司旗下的游戏——英雄联盟为背景做出的动漫，讲述了出生于祖安（底城）的一对姐妹，蔚和金克丝围绕着底城与皮尔特沃夫抗衡中相爱相杀的故事。 虽然我是不玩英雄联盟这款游戏的，但是每年的比赛总是以各种莫名其妙的方式火出圈导致我也慢慢有所关注，这部动漫还是在看直播的的时候发现的。 以前并不知道英雄联盟还有这么多奇特的故事，以动漫的形式讲述游戏里的剧情我觉得还是非常不错的，前提是得做的足够好，而大多数游戏改编的影视作品似乎都有种莫名的烂片诅咒，除了能让游戏玩家接受还要能不引起路人群体的负面观感，这样我就觉得足够好了，而双城之战远远超过我的期待值，虽然说它与日漫或国漫的画风上有着巨大的差别难以比较，但毫无疑问的双城之战担当得起2021年全球最佳动漫甚至影视作品。 连我这种动漫外行人、游戏云玩家都能切实感受到制作人对这部作品满满的诚意，六年时间的打磨、几千万美金的投资，只能用奢侈来形容，而这也无疑不是在表达自己对游戏的热爱，这是任何玩家群体都免不了为之赞叹、感动和羡慕的。 背景故事 双城之战的故事发生地点是皮尔特沃夫和祖安，也是剧中提到的上城和底城 在三千多年前恕瑞玛帝国统治的时代，祖安这座港口城市就兴起了，成为了瓦洛兰大陆和恕瑞玛大陆之间的通道，也成为了贸易中心。随着恕瑞玛的覆灭，港口城市独立成为祖安，两块大陆的一些权势家族在符文战争期间一方面为了躲避战乱一方面为了钱财吸引来到祖安这座城市，各大家族形成的议会成了这座城市的实际掌控者。 皮尔特运河为这座城市带来了繁盛的贸易与科技进步，但人心不足蛇吞象，大概在两百年前，祖安的几大家族通过议会决议，利用炸药拓宽运河在其上建造一个宏伟的闸桥日之门，但工程施工之时却发生了意外。炼金炸药爆炸的威力撼动了两块大陆板块的结构，导致祖安整座城市被撕裂。一部分城区上浮成为了上城，一部分城区下沉成为了下城，还有一部分城区沉入海底居民死伤无数。 日之门还是建造成功了，为上城带来了数不清的财富和资源，在此之后，有钱的贵族和商人不断巩固自己的地位，继续扩大皮城的繁荣。后来上城取名皮尔特沃夫，下城保留了祖安的原名。皮城通过日之门拥有数不尽的资源和财富，逐渐成了科技与进步之城。 有光明的地方必定有阴影，祖安作为牺牲的部分与之恰恰相反，成为了皮城的下水道，皮城科技实验形成的工业废水和炼金毒气都排进了祖安，不见光的黑市交易也聚集在了祖安，成为了肮脏低贱的代名词，充斥着贫穷打斗，各种团体的纷争，贫富悬殊、地位差距等等，而这成为了双城的永恒矛盾，导致双城之间的形势不断恶化，并且愈演愈烈，甚至曾带来了一场战争，故事就在这样的背景下开始了。 人物 剧中的主要人物大致有： 范德尔：以蔚为头儿、爆爆（金克斯）、克莱格、麦罗四人的监护人，也是底城中黑巷的代言人，曾带领底城人民冲过了底城与上城的桥梁，但见识到了战争的残酷后选择回到底城，尽自己所能维护底城人民的和平与生存，致力于阻止战争。死于希尔科之手，范德尔的死也直接导致了小时候金克斯和蔚之间反目。 希尔科：相当于底城教父般的人物，是该剧中的反派角色，也是范德尔曾经的好友，后因对战争意见不合与其分道扬镳。在剧中希尔科渴望恢复祖安彼时的荣耀，希望用战争带给皮城毁灭与恐惧，以此来换回底城的尊严，后来也成为了金克斯的第二位养父。 蔚：在底城与上城发生的那场战争中失去了父母，与爆爆是亲生姐妹，目睹过上城是如何对待底城人民后，对上城人民充满不满和愤怒。她性格急躁、脾气火爆、凶神恶煞，对权威满心不屑，为了能在底城生活下去练就了一身生存的本能。后来明白战争与死亡的痛苦，继承范德尔的意志阻止战争，一心想要铲除危害底城人们的毒瘤希尔科。 金克斯（爆爆）：年幼的金克斯是个胆小鬼，永远躲在蔚的身后，她渴望去证明自己，为团队提供自己的帮助，但是年幼且弱小的金克斯，将生存视作一场游戏，理所当然无法办到这样的事，并且最终将整个团队拉入深渊。间接害死范德尔后被蔚抛弃，自责、恐惧侵蚀她那弱小、自私和幼稚的心灵，灵魂上的折磨让她走上了与蔚截然相反的道路。 杰斯：杰斯小时候和妈妈在雪山遇险，然后在他的面前出现了一位神秘人，他施展出魔法将杰斯和昏迷的妈妈传送出雪山。长大后的杰斯一直在潜心研究海克斯科技，其核心就是魔法，他想给皮尔特沃夫带来大的改变，其中维克托就是他的研究伙伴，他们想要带领科技的进步。 维克托：维克托因为是下城人，虽然进入了上城，但是也一直被别人看不起。而且维克托还是一个瘸子，所以以后只能是一个助理，但是维克托却想要更加辉煌的未来，所以才找到了杰斯。和杰斯成为了好友，一起研究海克斯科技。 凯特琳：杰斯在学院中研究是被资助的，这个资助的他家庭正是凯特琳的家族。凯特琳也算是杰斯的青梅竹马，在很多人不理解的情况下，凯特琳成为了皮城女警，她也是一位不畏权横、勇于挑战自我、展现自我的人，誓要抓住扰乱上城安全的金克斯。后来与蔚同行，在底城经历了生死危机后对上城和底城有了不同的理解。 黑默丁格：黑默丁格是杰斯的学院院长，他用自己300多岁的阅历屡次来提醒杰斯，劝导他一定不要再研究魔法，停止海克斯科技，但最终却被自己的学生背叛，离开了议会。 剧情简述 第一集围绕着蔚、爆爆、克莱格、麦罗四人的视角，大致讲述了四人去上城偷盗物品，却意外造成了爆炸。为了解决这次事件，引出了执法人员和范德尔之间的拉扯和较量。 第二集讲述了蔚等四人偷盗的地点就是杰斯的实验室，但杰斯私自使用危险器具研究魔法是重罪，最后虽从轻处罚，但也失去了再次研究的能力，不过维克托对他的研究表示出了兴趣。 希尔科收买了一名执法官；同时“微光”（一种能大幅度提升生物体制，能在短时间内提供非常强大的力量，但也有成瘾性，也是希尔科后期对底城控制的重要手段）的研制也基本成功。 执法官在底城越发猖狂，底城部分人民也开始反抗范德尔平息、忍让的做法。蔚等四人一次次躲过了执法官的搜查，但深知不是根本解决办法，于是蔚决定牺牲自己来平息这次事件。 杰斯和维克托为了防止实验器具和研究报告被销毁，冒着被流放的的风险去黑默丁格的办公室实验，虽有波折，但最终证实了海克斯科技的成功， 就在上城为美好未来憧憬的时候，底城里范德尔阻止了蔚的行为，主动引罪，但希尔科利用收买的执法官，和他的微光战士出来截胡，杀了其他执法官和范德尔的好友本索，并抓走了范德尔。 目睹了一切的蔚决心营救范德尔，在最后即将成功的时候，被蔚留下的金克斯搞砸了一切，克莱格、麦罗、范德尔死亡，金克斯也被愤怒的蔚抛弃。希尔科决定收养金克斯，虽然蔚看见想去阻止，但被赶来的执法官带走成为了整个事件的主谋。 多年后，海克斯科技的创造物——海克斯飞门，其拥有能让飞船极快速度来往于城市之间，让杰斯名扬天下，同时也让他成为了历史上第一个第八位议员。 希尔科的手下赛维卡在上城港口走私微光，艾克（小不点）成立的野火帮阻止，双方发生战斗，给希尔科造成不小损失。之后金克斯又在进化日（皮城一年一度的庆祝日）引发爆炸，死伤数人。 凯特琳在爆炸中受伤，身为执法官的她决心找到凶手，于是她前往静水监狱寻找线索。 杰斯成为议员后开始整治各项问题，但自己也逐渐沉迷进权力之中，见识到了议员与富商之间的卑劣交易，职权的滥用，从上到下的腐败，自己也无法独善其身。 凯特琳认为蔚事关希尔科和金克斯等人，借口特赦了关押在静水监狱的蔚，并和她一同前往底城，与塞维卡一战后不仅导致蔚的受伤，也间接凸显出了微光的重要性。 维克托小时有一位老师，也是研发“微光”的人，微光的初衷就是想要使一个变种生物存活下去。 维克托生病，身体逐渐崩溃，但一心想在历史上留名，于是天天潜心研究海克斯科技，可当他发现延长寿命的可能后便逐渐走上了歪路。黑默丁格看到了海克斯核心可能的危害，决心毁灭它，但杰斯通过全体议会的同意使黑默丁格提前退休，罢免了其职位和权力。 蔚和金克丝姐妹相聚，但见面不过几秒就被野火帮攻击，蔚和凯特琳以及海克斯宝石全被带走 蔚见到了野火帮首领艾克，也就是小时的玩伴小不点，与凯特琳等人达成协议，将海克斯宝石带回上城平息这次事件，但在桥上遭遇马克思警长和金克斯，艾克与之一战，最后以双方脸吃炸弹结束。 希尔科的部分手下因为上城封桥利益阻断而将一切矛头指向希尔科，有意图造反、巩固地位的念想，但却被希尔科以雷霆手段压下。 维克多去底城见了以前的老师，并取得了改进版的微光，决定用在自己身上并进行海克斯核心实验。 希尔科带走了重伤昏迷的金克斯，不顾一切地救活她，从这里也能看出，希尔科和曾经的范德尔一样有了软肋，金克斯同样成为了他最想保护的人。 虽然议会是愚蠢且自大的，但他们也很清楚一点，战争是不到万不得已不能发动的，希尔科需要的是尊重，但尊重永远不可能是施舍来的，只能是自己获得，获得尊重的最好手段就是战争。 维克托注射微光后的实验完美成功了，但微光不够，强行实验的过程中一位仰慕他的学妹化为齑粉，永远消失。 蔚和杰斯达成短暂团结，摧毁了希尔科的制药基地，但是亲手杀死了一名小孩子也让杰斯迷茫、不知所措，不知如何是好。 最后一集描绘了许多人的视角，维克托失去学妹后的痛苦和悔恨，但是仍没有下手摧毁海克斯核心的决心；米达尔达议员的母亲当初将她逐出家族是因为女儿让她软弱；希尔科的部下再次蠢蠢欲动，甚至觊觎他的位置； “我是不是打扰你了”是维克托救下欲跳楼轻生的杰斯的说的一句话，而崩溃的维克托也反过来被相同的话，被自己拯救的人拯救。 希尔科终究不过成为了第二个范德尔","link":"/%E5%8F%8C%E5%9F%8E%E4%B9%8B%E6%88%98/"},{"title":"少女歌剧","text":"《少女歌剧》–我最喜欢的意识流动漫，至少在我看来是有点意识流的，她们的歌剧中讲述的不仅仅是她们自己的故事，也是我们的人生。世界在改变，我们不会有一成不变的舞台，鼓起勇气，拒绝这个悲剧的结局吧！ 少女歌剧，我很难去评价的一部作品，它的精彩程度让我难忘，时而欢快，时而悲恸，时而感动。 守护爱人的小光、誓要与她一起站在最高处的华恋、将美好永远留在这一刻的奈奈等等，她们身上的感情纯粹而又复杂，像交织在一起的蛛网，少女们慢慢地将其一一解开。 “舞台和舞台少女都是不断改变的” 正如长颈鹿说的那样，观众想看的是无法预测的舞台，不是无限重复的悲剧，无论是奈奈还是光，都是甘愿让自己承受一切，可你就是爱你的人的舞台，你们是彼此的星，这场悲剧该结束了，我否定这悲剧的结局。我的星星是你，你的星星是我，不是天上的那颗。 这部作品太过精彩，每一位角色的战斗都是独属于她自己的歌剧，从相知，到相爱，是那么的美丽。“闪耀”可以是任何你最珍贵的东西，或者你爱的人，在人生的这个舞台上，倾尽所有，打破一切，不去在意过去和未来，谱写你的命运。 再优秀的人也有忘记自我的时候。 –威廉·莎士比亚 人不同，时间流逝的速度也会不同。 –威廉·莎士比亚 不前进则后退，正如过去影响当下，未来也影响当下。 –尼采 做你想做的自己，永远都不嫌晚。 –乔治·艾略特 人生最大的失败是害怕失败。 –阿尔伯特·哈伯德","link":"/%E5%B0%91%E5%A5%B3%E6%AD%8C%E5%89%A7/"},{"title":"操作系统","text":"…… 绪论 操作系统定义 操作系统是核心系统软件，负责计算机系统软、硬件资源的分配和使用；控制和协调并发活动；提供用户接口，使用户获得良好的工作环境 操作系统的特性：并发性、共享、不确定性 操作系统的资源管理功能：处理机管理、存储器管理、设备管理、文件系统 UNIX操作系统是一个交互式和多用户分时系统，可移植，结构分为核心层和实用层，核心层包括进程管理，存储管理，设备管理，文件系统几个部分 操作系统的基本类型 批量操作系统、分时操作系统、实时操作系统 操作系统大多是多用户、多任务操作系统，采用的关键技术是并行处理技术和虚拟技术 层次机构 与基本机器硬件（裸机）紧挨的是系统核（基础核心）：初级中断处理、进程控制进程处理、处理机分派 往外是存储管理，I/O处理，文件存取，资源分配和调度 第2章 操作系统的结构和硬件支持 处理机的态及分类 管态：又称系统态，是操作系统的管理程序执行时及其所处的状态，可以使用所有的资源，允许访问整个存储区 用户态：又称目态，是用户程序执行时机器所处的状态，只允许用户程序访问自己的存储区域 第3章 操作系统的用户接口 系统功能调用的实现：操作系统的服务是通过系统调用来实现的，系统调用提供运行程序和操作系统之间的接口 第4章 进程及进程管理 进程的定义 所谓进程，就是一个程序在给定活动空间和初始环境下，在一个处理机上的执行过程 进程是竞争计算机系统有限资源的基本单位，也是进行处理机调度的基本单位 进程创建与撤销 创建原语：create 撤销原语：kill 等待原语：susp 唤醒原语：wakeup 若mutex=1，表示没有进程进入临界区 若mutex=0，表示有一个进程进入临界区 若mutex=-1，表示有一个进程进入临界区，另一个进程等待 进程通信方式：消息缓冲通道、信箱通道 线程的概念 线程是比进程更小的活动单位，它是进程中的一个执行路径 进程是任务调度的单位，也是系统资源的分配单位；而线程是进程中的一条执行路径，当系统支持多线程处理时，线程是任务调度的单位，但不是系统资源的分配单位。线程完全继承父进程占有的资源，当它活动时，具有自己的运行现场 第5章 资源分配与调度 死锁产生的原因：产生死锁的根本原因是系统能够提供的资源个数，比请求该资源的进程数要少。当系统中两个或多个进程因申请资源得不到满足，若各进程都没有能力进一步执行，系统就会发生死锁 产生死锁的4个必要条件： 互斥条件：资源一次只能被一个进程使用，必须等该资源被释放才能申请到该资源 不剥夺条件：进程所占用的资源在使用完成前，不能被其他进程强行夺走 占有并等待：进程每次申请资源时，继续占有已分配的资源 环路条件：存在一种进程的循环链，链中的每个资源都被进程占用，且被下一个资源请求 死锁的避免 有序资源分配法、银行家算法 第6章 处理机调度 作业调度的功能 确定数据结构 确定调度算法 分配资源 善后处理 作业调度算法 先来先服务调度算法 短作业优先调度算法 响应比高者优先调度算法 第7章 主存管理 虚存的定义 计算机系统在处理应用程序时，只装入部分程序代码和数据就启动运行，由操作系统和硬件相配合完成主存和辅存之间的信息的动态调度，这样的计算机系统好像为用户提供了一个其存储容量比实际主存大得多的存储器，这个存储器称为虚拟存储器，之所以叫虚拟存储器，是因为这样的存储器实际并不存在，是由于系统提供了自动覆盖功能后，给用户造成的一种虚拟的感觉，仿佛有一个很大的主存供他使用一样 虚拟存储手段扩充主存的方法：分页式存储管理、分段式存储管理、段页式存储管理 分区存储管理 放置策略： 首次适应算法（按地址查找第一个能装人它的空闲区） 最佳适应算法（将程序放入主存中与它随需大小最接近的空闲区） 最坏适应算法（将程序放入最不适应它的空闲区，及最大空闲区内） 第8章 设备管理 缓冲技术 中断技术和通道技术可以缓解CPU和I/O设备间速度不匹配的问题","link":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"title":"数据库原理及应用教程基础","text":"数据库，简单地说就是数据的仓库，即数据存放的地方 数据库系统概述 信息 信息的特征： 信息源于物质信息是可以感知的信息是可储存、加工、传递、和再生的 数据 数据的表现形式：数字、文字、图形、图象、声音和视频 信息与数据之间的联系：数据是信息的符号表示，信息是对数据的语义解释 数据库：存储在计算机中的数据集合 数据管理经过了三个发展阶段：人工管理、文件系统和数据库系统 人工管理阶段数据没有专门的存取设备，没有专门的管理软件、数据不共享、数据不具有独立性 数据独立性指数据库中数据与应用程序间相互独立，逻辑结构、存储结构及存取方式改变不影响应用程序 独立性有物理独立性和逻辑独立性 物理独立性指物理结构（存储结构、外部存储设备）发生变化，通过修改映射，用户逻辑结构和应用程序不改变逻辑独立性指逻辑结构（修改数据定义、增加数据类型）发生变化，通过修改映射，用户逻辑结构和应用程序不改变 文件系统阶段数据以文件形式长期保存，有程序与数据之间有独立性，数据有一定共享性 数据库系统阶段数据结构化，数据共享型高，独立性高，有统一的数据管理和控制功能 数据控制功能：数据的安全性控制、完整性控制、并发控制、数据恢复 数据库系统 数据库系统包括数据库和数据库管理系统 数据库系统的组成：数据库、用户、软件系统、硬件系统 第一类用户：最终用户-&gt;非计算机专业人员 第二类用户：应用程序员-&gt;调试和安装 第三类用户：数据库管理员-&gt;设计、管理、维护数据库，协调用户 三级模式：外模式、模式、内模式（用户模式、概念模式、物理模式） 模式（概念模式）：是数据库中全体数据的逻辑结构和特征的描述 外模式（子模式/用户模式）：是数据库用户能看到看到并允许使用的数据的逻辑结构和特征的描述 内模式（存储模式/物理模式）：是对数据库存储结构的描述 外模式可以有多个，模式和内模式只能各有一个 外模式/模式映像，描述数据的全局逻辑结构 模式/内模式映像，描述数据的全局物理结构 二级映像的优点：保证数据的独立性、简化了用户接口、有利于数据共享、有利于数据的安全保密 数据库管理系统（DBMS） 数据库管理系统（DBMS）是数据库系统的核心组成部分，包括定义、查询、更新（插入、删除和修改）及各种控制 用户在数据库系统中的一切操作都是通过数据库管理系统进行的 DBMS主要功能：数据定义功能、数据操操纵功能、数据库运行管理功能、数据库的建立和维护功能、数据通信接口及数据组织、存储和管理功能 数据库运行管理是DBMS运行的核心部分 数据模型的组成要素 数据结构、数据操作、数据的完整性约束 数据结构：层次结构、网状结构、关系结构 数据操作有查询和更新（插入、删除和修改） 完整性约束保证数据正确、有效、相容 四种数据模型 层次模型、网状模型、关系模型、面向对象模型 层次模型采用树形结构表示各类实体以及实体间的联系 网状模型采用有向图结构表示记录型与记录型之间联系的数据模型 关系模式的数据结构是一张规范化的二维表 面向对象模型中最基本的概念是对象和类 关系数据库 候选码：能标识关系中元组的一个属性或属性集，如：学号、身份证号或二者相加 主码：如果一个关系中有多个候选码，选择其中一个作为主码 关系代数运算 基本代数运算：并、差、笛卡儿积、选取、投影 传统的代数运算：并、差、交、笛卡尔积 专门的代数运算：选取、投影、连接、除 关系数据库标准语言——SQL SQL是结构化查询语言（Structured Query Language）的缩写 SQL语句 数据定义：CREATE（创建）、ALTER（修改）、DROP（删除） 数据操纵：INSERT INTO（插入表中记录）、UPDATE（修改表中记录）、DELETE（删除表中记录） 数据查询：SELECT（查询） 聚合函数：AVG（平均值）、SUM（总和）、MAX（最大值）、MIN（最小值）、COUNT（统计个数） WHERE和HAVING WHERE：筛选出表中满足条件的行，不可与聚合函数连用 HAVING：筛选出满足条件的组，可与聚合函数连用，通常与GROUP BY连用 数据表中数据的操纵 添加表中数据，INSERT INTO 123/*在 S 表中添加一条学生记录*/INSERT INTO S (sno, sn, age, sex, dept)VALUES ('s1', '张三', 20, '男', '计算机') 1234567/*添加多行记录INSERT INTO 表名子查询*/INSERT INTO SSELECT dept, AVG(sal)FROM TGROUP BY dept 修改表中数据，UPDATE 123UPDATE TSET dept='会计'WHERE TN='刘伟' 删除数据，DELETE 123DELETEFROM SWHERE sn='张三' 视图 视图的概念：视图是一个虚拟表，其内容由查询定义，视图包含带有行和列的数据，但是视图并不存储数据。 视图的作用：通常用来简化用户操作，使用户以多种角度看待同一数据，对重构数据库提供了一定程度的逻辑独立性，更清晰的表达查询 视图可以用作安全机制，允许用户通过视图访问数据，而不授予访问数据表的权限，视图本身并不包含数据，保存的是查询语句 创建视图 1234CREATE VIEW 视图名(属性1,属性2,属性3...)AS SELECT 属性1,属性2,属性3...FROM 表名1,表名2...WHERE ... 索引 两种基本类型的索引：聚集索引、非聚集索引 数据库安全保护 数据库安全性的含义 数据库的安全性是指保护数据库以防止非法使用所造成的数据泄露、更改或破坏（防止非法操作） SQL Server身份认证，认证的是和服务器的连接 数据库完整性的含义 数据库的完整性是指保护数据库中数据的正确性、有效性和相容性，防止错误的数据进入数据库造成无效操作（保护数据的一致性） 实时数据库完整性的方法有：约束、默认值、规则、存储过程和触发器 事务 事务是数据库中执行的一个工作单位，由用户定义的一组操作。可以是一组SQL语句、一条SQL语句或整个程序 定义事务的语句有三条 123456BEGIN TRANSACTIONCOMMITROLLBACK其中BEGIN TRANSACTION表示事务的开始；COMMIT表示事务的提交，正常结束；ROLLBACK表示事务的回滚，即运行过程中发生了某种故障，回滚到开始状态 事务有四个特征：原子性、一致性、隔离性、持久性（ACID准测） 并发操作与数据的不一致性 数据库的并发操作导致的数据库不一致性主要有三种：丢失更新、污读（读脏数据）、不可重读 封锁 封锁类型：排他型封锁（X锁）、共享封锁（S锁） 排他型封锁：禁止并发操作（事务T对某个数据对象R实现X封锁后，其他事务要等T解除X封锁以后，才能对R进行封锁，这就保证了其他事物在T释放R上的封锁之前，不能再对R进行操作） 共享封锁：允许其他用户对同一数据对象进行查询，但不能对该数据对象进行修改 封锁协议： 一级封锁协议（不能防止“污读”和“不可重读”） 二级封锁协议（能防止“污读”，不能防止“不可重读”） 三级封锁协议（既能防止“污读”，也能防止“不可重读”） 封锁粒度：封锁的数据对象大小称为封锁粒度，封锁粒度越小能够被封锁的对象就越多，并发度越高，烦封锁机构越复杂，系统开销也越大，反之亦然，选择封锁粒度时应考虑封锁机构和并发度两个因素，以求得最优解。 活锁和死锁 死锁产生的条件： 互斥条件：一个对象只能被一个事务使用，即对数据的封锁采用排他式 不可抢占条件：一个数据对象只能被占有它的事务所释放，而不能被别的事务强行抢占 部分分配条件：一个事务已经封锁分给它的数据对象，但仍然要求封锁其他数据 循环等待条件：允许等待其他事务释放数据对象，系统处于加锁请求互相等待的状态 死锁的预防：一次加锁法、顺序加锁法 死锁的诊断与解除：选择一个处理死锁代价最小的事务，将它撤销，解除它的死锁，释放此事务占用的所有数据资源，分配给其他事务 数据库的故障和恢复的策略 事务故障及其恢复、系统故障及其恢复、介质故障及其恢复 数据库设计 数据库设计步骤：系统需求分析、概念结构设计、逻辑结构设计、物理结构设计、数据库实施、数据库运行和维护 SQL Server高级应用 Transact-SQL 全局变量：全局变量是SQL Server系统内部使用的变量，使用全局变量必须以“@@”开头 局部变量：局部变量使用户可以自定义的变量，且局部变量名前必须以@为前缀 局部变量必须先用DECLARE命令声明后才可以使用 123/*声明一个长度为8个字符的局部变量id*/DECLARE @id char(8)SELECT @id='12345678' 1234DECLARE @sno varchar(10),@sn varchar(10)SELECT @sno=SNo,@sn=SNFROM SWHERE SNo='S7' 触发器是一种特殊的存储过程，但触发器能够自动执行并且不含有参数 触发器的种类： DML触发器：DML触发器是在执行数据操作语言（DML）事件时被激活而自动执行的触发器 根据触发器代码执行的时机，DML触发器可以分为两种：After触发器和Instead of触发器 After触发器是在执行了INSTERT、UPDATE或DELETE语句操作之后激活执行的触发器，也是就在记录已经变完之后（After）才会激活执行，这种触发器只能在表上定义，不能在视图上 Instead of触发器是在执行INSTERT、UPDATE或DELETE语句操作之前激活执行的触发器，也就是记录变更之前，不去执行SQL语句里插入、修改或删除操作，而去执行触发器种的代码所定义的操作，可以定义在表和视图上 DDL触发器：DDL触发器是在响应各种数据定义语言（DDL）事件时而激活执行的存储过程 登陆触发器：由登陆（LOGON）事件而激活的触发器，建立用户会话时将引发此事件 每个触发器都有两个特殊表：插入表（Inserted）和删除表（Deleted），这两个表都是系统在线生成的、动态驻留在内存种的临时表，是由系统管理的逻辑表 备份和还原 备份类型：数据库完整备份、差异备份、事务日志备份、文件及文件组备份 还原模式：简单还原、完全还原、批日志还原 各章习题文件 各章习题参考答案 简答题及答案","link":"/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E6%95%99%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"title":"漂流少年","text":"前言：第一次接触这部片子，是在一位up的推荐视频里，我个人是不喜欢开弹幕看视频的，因为近年来弹幕对视频的负面影响愈来愈严重，但是有时弹幕也是一种跨越时空的交流，给人不少建议。“很好看”“墙裂推荐”“这部番超级好看的”等等词语或短句在这部片子播放的时候出现，独特的画风让我（感到好奇）眼前一亮，处处透漏着大胆和开创先锋的勇气，至于是否真的是开创了动漫的一条道路，还是又给二次元这片草原添一土坟，就得在看过之后才能下定义了，又或者我根本就没打算去真的看懂这部片子…… 第一集一部动漫的开篇，一般是去讲述这个故事的背景和开始，然后展现主角或者配角的性格和人为，或孤僻而善良，或勇敢而弱小，或强大而懦弱。 这部片子的背景是，一座中学学校的三年级学生长良一行人进入了一个特殊的世界，那里只有学校这座建筑，学校之外都是无边无际的黑暗。越来越多的学生逐渐发现自己的（超）能力，一名叫做朝风的学生能力尤为突出，在练习能力中不断破坏玻璃（学校建筑被破坏后也会恢复原）。一位学生明星（初看并不像什么好人）设法建立了学生会这一组织，希望学生在没有老师的监管下也可以有序的生活，但是与习惯自由的朝风冲突，最后演化为轻微暴力事件。此次事件还未结束，女主希尝试逃离这里，沿着天台的一边跳进黑暗中，于是黑暗消失，大海出现了，与之出现的还有一座小岛。 第二集该集主要讲述了女二瑞穗的背景和其初期的成长。学生们在小岛中定居，瑞穗利用自己制造物品的能力（其实是“喵马逊”，无论她想要什么，她身边的三只猫都会复制一份带过来）为大家提供便利，但瑞穗性格我行我素，不屑于与周围人搞好关系，一直孤立着。同时男二拉吉塔尼也展现出自己的智商才能，致力于探究这个世界，为同学们一些疑惑。瑞穗制造出的东西在同学们手中自然，发出蓝色火焰，被同学冤枉，后又被明星一行人裹挟，造成全岛的燃烧，拉吉塔尼将误会解开后也表示蓝色火焰是因为东西都是通过非交易手段获得，使用就会自然，要想获得他人的东西就要用“漂流币”（拉吉塔尼创造的虚拟货币）交易。 瑞穗在引发全岛大火的同时，长良发现了瑞穗的一只走丢的猫，穿过大火将猫送到了瑞穗面前，至此瑞穗和长良之间诞生友谊。 第三集在这个世界里，有各式各样的“门“，长良很擅长找门，门中有各式各样不同的世界，很多都不适合人类生存。岛中出现一些怪事，陆续有同学变成一动不动的黑色人影，瑞穗被委托调查这件事，顺带带上了长良，二人在一处山丘发现了门，消失的同学们都在其中，摧毁门（门其实是一片幕布）后救出同学们。 在此事件的过程中瑞穗因为讨厌长良懦弱而不善表达的性格和长良产生矛盾，事件结束后两人又握手言和。或许这映证着长良的第一次成长。","link":"/%E6%BC%82%E6%B5%81%E5%B0%91%E5%B9%B4/"},{"title":"莫名其妙的傻逼幻想","text":"最让人感到欣喜的评价不是“你好厉害呀” “你好棒呀” “你怎么做到的啊”而是面带惊喜“你的歌单好好听呀” 说实话让我有点犯恶心 对一个人说“我想了解一下你的歌单”会不会显得还有点暧昧 当然不会如果是我甚至会吐口唾沫再走","link":"/%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E7%9A%84%E5%82%BB%E9%80%BC%E5%B9%BB%E6%83%B3/"},{"title":"Java开发入门","text":"Java第一部分 项目 1：Java 开发环境的搭建简介：看下图⬇ .pdf { /*max-width: 100%;*/ width: 100%; height: 700px; border: 10px solid rgba(0,1,1,.2); margin: 0; } 下载pdf文件","link":"/Java/Java01/"},{"title":"紫罗兰永恒花园","text":"“只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登” OP 每每学会未知的词语 仿佛触及你的追忆 但是或许也会有单词 只身一人 终究无法理解 再见 是苦涩的 我爱你 则带着遥远的气息 无可比拟的这份情愫 让我胆战心惊 却又让我心动不已 为什么的眼里噙满泪水 该怎么回答我的心灵 话语总在嘴边 越是说不出口 越是揪人心肠 让我想要与你相见 “对我来说，那个人的存在就是我的整个世界，要是他离我而去，那我也唯有一死” “薇尔莉特，怎么样，你在看吗？” “我在，这是我第一次这么近的看星星” “不是星星，是彗星！” “我们今生今世再也不能与它相见了” “然此非悲恸之别离 逝者当于 久远之妖精之国 得新生 其魂不灭 亘古永存” “只要是客人的愿望，不论天涯海角我们都竭诚为您服务，自动笔记人偶服务薇尔莉特·伊芙加登” “这把伞就是你的翅膀，但要是飞得太高会被风儿卷走，所以在海上就踏着浪花，在溪上就踏着青石，在湖面就踏着落叶飞回去” 剧场版-终 首先我得承认，我是不希望在荧幕上看到这位少校活蹦乱跳的，因此你们可以认为我对终章的剧情并不很喜欢。其实我对整部剧的剧情的评价都不算太高，讲的高情商一点，该剧是有点意识流的，很多剧情有点点强硬，着重描写了人物们的情感，加上优美的背景和动听的音乐将其渗入每一位观众的心中，以此来产生共鸣，以至于对剧情方面有所欠缺，但都还可以接受。倒不如说这些方面很大程度地拉高了这部剧的逼格，剧情就显得粗糙且突出。 剧场版或者说终章的剧情相比较TV是有很大进步的，大概 7->8.5 分这样的进步，加上 9.9999 分的画风和 9.9999 分的音乐，9.5 分的评价并不为过。无论是苦苦追寻爱意的薇尔莉特，还是怀着赎罪之心的少校，在他们相遇的那一刻，无言便是对双方最好的回答。 其实我这个人是不适合与别人相爱的，因为我的身上总是充斥着各种各样负面的情绪，也许会给人一种不太舒服的感觉？，我自己虽然不在意这些，但总要为别人着想一些。这时候就有人说了：那你既然都知道自己的缺点了，改一改就好了呀，如果碰上喜欢的人不就成了吗。啊~曾经有一份真挚的爱情摆在我面前，可我却（啪！）总之就是因为各种原因，我这人似乎已经定型了，我自己没那毅力改，别人帮我慢慢改的话我估摸着也早都把人给逼走了，而且我大多数时候也不太会为别人着想。啊~我好废物啊，每天就靠着这些恋爱、快乐的番剧过活了，死肥宅的生活真好。其实我也蛮歌颂爱情的，可能类似于叶公好龙？ 我爱你，这三个字如山石般沉重，让人步履维艰；如羽毛般轻盈，让人踏遍山河；如云雨般漂泊，让人魂牵梦绕；如草木般倔强，让人向死而生。 祝愿世界上每一个生物都有能有配偶 :-D 温馨提示：爱情只是亲情与友情的混合产物，虽珍重，但也没必要过分强求。 温馨提示的温馨提示：为了爱情改变自己是爱一个人的表现，但过分的纵容不是。 自己截下来的一些图片：","link":"/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/"}],"tags":[{"name":"动漫","slug":"动漫","link":"/tags/%E5%8A%A8%E6%BC%AB/"},{"name":"EVA","slug":"EVA","link":"/tags/EVA/"},{"name":"HEXO","slug":"HEXO","link":"/tags/HEXO/"},{"name":"gitalk","slug":"gitalk","link":"/tags/gitalk/"},{"name":"HUGO","slug":"HUGO","link":"/tags/HUGO/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"知识","slug":"知识","link":"/tags/%E7%9F%A5%E8%AF%86/"},{"name":"技术","slug":"技术","link":"/tags/%E6%8A%80%E6%9C%AF/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"文章置顶","slug":"文章置顶","link":"/tags/%E6%96%87%E7%AB%A0%E7%BD%AE%E9%A1%B6/"},{"name":"win10+多仓库配置","slug":"win10-多仓库配置","link":"/tags/win10-%E5%A4%9A%E4%BB%93%E5%BA%93%E9%85%8D%E7%BD%AE/"},{"name":"大数据概论","slug":"大数据概论","link":"/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%A6%82%E8%AE%BA/"},{"name":"双城之战","slug":"双城之战","link":"/tags/%E5%8F%8C%E5%9F%8E%E4%B9%8B%E6%88%98/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"垃圾桶","slug":"垃圾桶","link":"/tags/%E5%9E%83%E5%9C%BE%E6%A1%B6/"},{"name":"Java开发入门","slug":"Java开发入门","link":"/tags/Java%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"}],"categories":[{"name":"动漫","slug":"动漫","link":"/categories/%E5%8A%A8%E6%BC%AB/"},{"name":"博客","slug":"博客","link":"/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"Node.js","slug":"Node-js","link":"/categories/Node-js/"}]}